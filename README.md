# 读我读我读我

> 先讲讲故事吧。
> 
> 故事发生在一个盛夏，平凡的一天，孩子们在教室里打着 OJ, 一切安详又美好。
> 
> 如果故事真的就这样发展下去的话，那自然是没什么看头的。显而易见，某种特殊的事情发生了，比如说，有名同学突发奇想，试验性地制作了一个快速聚合类文件的操作实现。
> 
> 很难得这样一个些许带着取乐、玩票性质的项目，渐渐又试着走向一个更有趣的方向——兴许带着些为下一届同学谋福利的想法吧，我们决定实现这样一个简单的插件。
> 
> 那么，就让我们开始吧。

## 项目目标

### 基本目标

实现一个 Java 程序 OJ 提交助手

目标分为如下几个模块：

1. 代码处理器：核心模块，负责整合、处理代码。
1. 输出器：将结果运输至剪贴板。
1. [可选]上传工具：上传代码至互联网（自动提交代码至合适问题处）。

下面分别讨论各个模块的抽象描述和具体实现步骤。

### 代码处理器模块

我们不妨张开想象的翅膀，举个具体的例子，来试着考虑我们目前设计的「最简单」的代码处理器所需要提供的功能。

考虑这样一个问题：

*请输出 "Hello World" 作为你的第一个程序！*

无知年幼的少年写了以下代码：

```java
packge dsaa.lab01; 

public class HelloWorldPrintingQuestion {
    public static void main(String[] args) {
        System.out.println("Hello World"); 
    }
}
``` 

显而易见，通过我们的 *Code Parser*, 它会变成：

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World"); 
    }
}
``` 

毫无疑问，这是我们的设计的重中之重——因为任何一个需要 parser 的文件，都必然面对着这一部分不得不处理的内容。

下面，我们进入到功能模块分析上来。

#### 主类实例化处理

正如前文所说，主类名的变换处理是一件非常麻烦的事情。它的麻烦不仅仅体现在本身的 package 变换上，更体现在方法调用时的实例化上。

我不妨出一道题吧：

题目：**斐波那契视野下的泊松流**

描述：众所周知，泊松分布基于事件概率极低且实验次数极大情形下，对事件在给定试验次数內推测事件发生次数的一种很好的近似方式。

在排队论中，泊松流是最简单的一种流。它描述了一种很有趣的随机事件模型。

那么，让我们考虑一对小肥兔，它们每月都能够产下一对新肥兔。正如我们的常识所记载的那样，兔子只需要一个月就能够长大，因此，我们不必担心这个兔子会懈怠太久。

考虑我们目前拥有的兔子对数是 1. 由于某种玄而又玄的原因，兔子会有某种概率猝死——经研究表明该概率大小为 $\alpha$, 科学院对此作出了特殊保证，它们认为这是一个泊松流模型——死神每月会有 $\alpha$ 的概率来到某个兔子身边并将它带走，值得留意的是，一只兔子被带走并不影响死神带走另一对兔子，但兔子总是成对成对被带走，因为它们缔结了某种「生死同盟契约」。

不过无论如何都没有关系，我们正在寻找某种稳态，以使得兔子能更好的活下去！

接下来让我们进入游戏环节吧！

---

输入描述

一个浮点数，$\alpha$. 

输出描述

稳态数学概率期望意义下的兔子对数。

输入样例

1.00 

输出样例

0 

提示

如果你想问为什么输入样例怎么简单，那当然是因为太复杂我也不会呀 hhh. 

---

```java
package dsaa.lab01; 

// 简单的兔兔问题模拟器
public class Rabbit implements Cloneable{
    private static double deathRate; 

    private int number; 

    public static void main(String[] args) {
        Rabbit r1 = new Rabbit(); 
        Rabbit r2 = new Rabbit(); 
        Rabbit r3 = r1.clone(); 
        // todo: write something else. 
        System.out.println("这道题由读者自行练习。");
    }

    @Override 
    public Rabbit clone() {
        try {
            Object o = super.clone(); 
            return (Rabbit)o; 
        } catch (Exception e) {
            throw new RuntimeException(e); 
        }
    }
}
```

显而易见，该主类制造了它的实例——这会是一个必要的需要处理的地方，当然，也许我们可以禁止这样的行为：不允许为主类创造实例！

另一方面，内部类同样会成为一个好的办法来避免这个问题——甚至，我们可以把包全部变成内部类以避免其他问题的出现。<u>这会是一个实验性的解决方案。</u>

#### 导入同目录类

[todo] 等待处理

### 代码粘贴器模块

该部分内容比较简单，不妨在第一版本內将其彻底完成。

工作分成两部分：获取能够操控剪贴板的 API, 调用该 API 将期望输入的代码放入剪贴板中！

该任务需要处理的难点如下：

- 如何在 *IDEA platform* 下找到提供对剪贴板控制的方法。
- 如何保证该方法的稳定性/鲁棒性——在剪贴板空间容量不足、无法获取等情况下能够正确提供异常相关的信息反馈。

## Version 1

<div align="right">Sun Jan 23 17:43:37 CST 2022
</div>

Description: This is the first version. Using this plugin, you can easily get your codes in your clipboard to submit in your Online Judge website. 

### Code Dealing Automata 

We determine some patterns to express the *Java* codes. 

# 简易 Java 词法分析器 Version 2 

现列出我们目前对 Java 的语法假设：

- 双引号包含的部分为「字符串直接量」，其优先级高于注释描述。
- 注释描述分 `//` 和 `/* ... */` 两类，进入注释后其优先级高于字符串。其中，`//`、`/* ... */` 两种注释并行运行，互不影响干涉！
- 类名分析，考虑将类名也统一划分在一起。

考虑几种特殊的 token 描述： `->` 与 `-` 需要特殊判断 - 后面的符号以便决议接下来的结果。
同理，除号 `/` 和 注释描述符号 `//`, `/*` 需要等待下一个字符描述以便决议结果！

因此，词法分析器有如下四种状态描述：
- 普通状态，一般情形的词法读入都在该状态进行。
- 字符串描述状态，该状态需要等待一个双引号以便退出该状态。
- 注释豁免状态，该状态获取的字符都应忽略不计。
- 等待词法决议状态，负责分析接下来需要决议的词语以及结果！

常见的需词法决议的修饰符如下：
- `<=`, `>=`, `==`, `!=`
- `&&`, `||` 